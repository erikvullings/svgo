<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced SVG Optimizer</title>
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="shortcut icon" href="favicon.ico">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="android-chrome-192x192.png">
  <meta name="theme-color" content="#ffffff">
  <meta property="og:title" content="Advanced SVG Optimizer">
  <meta property="og:description" content="Optimize and transform your SVG files for better performance and rendering.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://erikvullings.github.io/svgo/">
  <meta property="og:image" content="https://erikvullings.github.io/svgo/android-chrome-512x512.png">
  <meta property="og:image:width" content="512">
  <meta property="og:image:height" content="512">
  <meta property="og:image:alt" content="Advanced SVG Optimizer Logo">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@yourtwitterhandle">
  <meta name="twitter:creator" content="@yourtwitterhandle">
  <meta name="twitter:title" content="Advanced SVG Optimizer">
  <meta name="twitter:description"
    content="Optimize and transform your SVG files for better performance and rendering.">
  <meta name="twitter:image" content="https://erikvullings.github.io/svgo/android-chrome-512x512.png">
  <meta name="description"
    content="An advanced online tool to optimize, clean, and resize SVG files, improving performance and compatibility.">

  <script src="https://cdn.jsdelivr.net/npm/mithril@2.3.8/mithril.min.js"></script>
  <!-- <script type="module" src="https://cdn.jsdelivr.net/npm/svgo@3.3.2/dist/svgo.browser.min.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/vs/loader.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      height: 100vh;
      overflow: hidden;
    }

    .header {
      background: #2a2a2a;
      padding: 1rem;
      border-bottom: 1px solid #404040;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #4fc3f7;
      display: flex;
      align-items: center;
      gap: 0.8rem;
    }

    .logo {
      height: 32px;
      width: 32px;
    }

    .stats {
      display: flex;
      gap: 2rem;
      font-size: 0.9rem;
    }

    .stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .stat-label {
      color: #888;
      font-size: 0.8rem;
    }

    .stat-value {
      font-weight: 600;
      color: #4fc3f7;
    }

    .controls {
      background: #2a2a2a;
      padding: 1rem;
      border-bottom: 1px solid #404040;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem 0;
      align-items: center;
      max-height: 140px;
      overflow-y: hidden;
    }

    .file-input {
      position: relative;
      display: inline-block;
    }

    .file-input input[type=file] {
      position: absolute;
      left: -9999px;
    }

    .controls>button {
      height: 40px;
    }

    button,
    .file-button {
      background: #4fc3f7;
      color: #1a1a1a;
      border: none;
      padding: 0.4rem .8rem;
      margin-right: 10px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
      font-size: 18px;
      cursor: pointer;
    }

    label.file-button {
      padding: 0.6rem .8rem;
    }

    button {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: larger;
    }

    button:disabled {
      background: grey !important;
      cursor: text;
    }

    button:hover,
    .file-button:hover {
      background: #29b6f6;
    }

    .option-group {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checkbox-group input[type="checkbox"],
    .checkbox-group input[type="radio"] {
      accent-color: #4fc3f7;
    }

    .number-input {
      width: 60px;
      background: #404040;
      border: 1px solid #555;
      color: #e0e0e0;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .dimension-input {
      width: 80px;
      background: #404040;
      border: 1px solid #555;
      color: #e0e0e0;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .main-content {
      display: flex;
      height: calc(100vh - 200px);
    }

    .editor-panel,
    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      background: #333;
      padding: 0.5rem 1rem;
      font-weight: 600;
      border-bottom: 1px solid #404040;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 42px;
    }

    .download-btn {
      background: #4caf50;
      color: white;
      border: none;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .download-btn:hover {
      background: #45a049;
    }

    .editor-container {
      flex: 1;
      position: relative;
      padding-top: 10px;
      overflow: hidden;
    }

    .preview-container {
      flex: 1;
      padding: 1rem;
      overflow: auto;
      background: #2a2a2a;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .svg-preview {
      max-width: 100%;
      max-height: 100%;
      border: 1px solid #404040;
      background: white;
    }

    .error {
      color: #f44336;
      padding: 1rem;
      background: #330000;
      border: 1px solid #660000;
      border-radius: 4px;
      margin: 1rem;
    }

    .drop-zone {
      border: 2px dashed #4fc3f7;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      margin: 1rem;
      background: #2a2a2a;
      transition: all 0.2s;
    }

    .drop-zone.dragover {
      background: #3a3a3a;
      border-color: #29b6f6;
    }

    .reduction-indicator {
      font-weight: 600;
    }

    .reduction-positive {
      color: #4caf50;
    }

    .reduction-negative {
      color: #f44336;
    }

    .svg-preview {
      transform-origin: center center;
      transition: transform 0.2s ease-in-out;
    }

    .main-content {
      display: flex;
      height: calc(100vh - 200px);
      resize: horizontal;
      overflow: auto;
    }

    #dragbar {
      z-index: 10;
    }

    #left-panel,
    #right-panel {
      overflow: hidden;
      height: 100%;
    }

    .tree-view {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 1rem 0;
      background: #222;
      color: #ccc;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9rem;
      user-select: none;
      white-space: nowrap;
      scrollbar-color: #555 #222;
    }

    .tree-content {
      overflow-y: auto;
      overflow-x: hidden;
      max-height: 100%;
    }

    .tree-view::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    .tree-view::-webkit-scrollbar-track {
      background: #222;
    }

    .tree-view::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 6px;
      border: 2px solid #222;
    }

    .tree-view::-webkit-scrollbar-thumb:hover {
      background: #666;
    }

    .tree-view::-webkit-scrollbar-corner {
      background: #222;
    }

    .tree-node-wrapper {
      position: relative;
      width: max-content;
      min-width: 100%;
    }

    .tree-node-header {
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 0.5rem;
      /* padding: 0.2rem 0; */
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
      /* border: 1px solid transparent; */
      white-space: nowrap;
      width: 100%;
      position: relative;
    }

    .tree-node-header:hover {
      background: #333;
    }

    .tree-node-header.selected {
      background: #3a3a3a;
      border-color: #4fc3f7;
    }

    .tree-node-header.drag-over {
      border: 2px dashed #4fc3f7;
      background: #444;
    }

    .tree-prefix {
      color: #555;
      white-space: pre;
      flex-shrink: 0;
    }

    .tag-name {
      color: #4fc3f7;
      font-weight: 600;
      flex-shrink: 0;
    }

    .attributes {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.4rem;
      flex-grow: 1;
      align-items: center;
      padding-right: 4rem;
      /* Space for controls */
    }

    .attribute {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      font-size: 0.8rem;
      flex-shrink: 0;
    }

    .attr-name {
      color: #9cdcfe;
    }

    .attr-value-container {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .attr-value {
      color: #ce9178;
      border: none;
      background: rgba(255, 255, 255, 0.05);
      padding: 0 4px;
      border-radius: 2px;
      max-width: 200px;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: text;
      font-family: inherit;
      font-size: inherit;
      box-sizing: content-box;
    }

    .attr-value:focus {
      background: #444;
      outline: 1px solid #4fc3f7;
      max-width: none;
      z-index: 10;
    }

    .attr-value-full {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: #333;
      color: #ce9178;
      padding: 0.5rem;
      border: 1px solid #4fc3f7;
      border-radius: 4px;
      z-index: 100;
      max-width: 400px;
      word-break: break-all;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
      white-space: normal;
    }

    .attr-value-container:hover .attr-value-full {
      display: block;
    }

    .node-controls {
      display: flex;
      gap: 0.2rem;
      margin-left: auto;
      padding-left: 0.5rem;
      padding-right: 0.5rem;
      position: sticky;
      right: 0;
      background: #222;
      /* Match tree bg */
      z-index: 5;
      opacity: 0;
      transition: opacity 0.2s;
    }

    /* Change background when hovering row so it blends */
    .tree-node-header:hover .node-controls {
      background: #333;
      opacity: 1;
    }

    .tree-node-header.selected .node-controls {
      background: #3a3a3a;
      opacity: 1;
    }

    .control-btn {
      background: #444;
      color: #eee;
      border: none;
      padding: 0.1rem 0.3rem;
      border-radius: 2px;
      cursor: pointer;
      font-size: 0.7rem;
    }

    .control-btn:hover {
      background: #555;
    }

    /* Base highlight for text – works on both dark & light backgrounds */
    .highlighted-preview {
      fill: #00ffff !important;
      /* vivid cyan – excellent contrast */
      font-weight: bold !important;
      /* makes it stand out more */
      cursor: pointer;
      /* optional – signals interactivity */
    }

    /* Strong glow using drop-shadow filter – very reliable for SVG */
    .highlighted-preview {
      filter:
        drop-shadow(0 0 3px #00ffff)
        /* tight inner/near glow */
        drop-shadow(0 0 8px #00ffffaa)
        /* medium glow */
        drop-shadow(0 0 14px #00ffff55);
      /* soft outer halo */
    }

    /* Alternative: white + dark outline (very clean & readable) */
    .highlighted-preview.white-outline {
      fill: white !important;
      paint-order: stroke fill;
      /* stroke paints first = outline */
      stroke: black;
      stroke-width: 2.8px;
      /* adjust 2–4 px depending on font-size */
      filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.7));
    }

    /* Red attention style (good for warnings/errors) */
    .highlighted-preview.red-alert {
      fill: #ff4d4f !important;
      filter:
        drop-shadow(0 0 4px #ff4d4f) drop-shadow(0 0 10px #ff4d4faa);
    }

    /* Yellow high-contrast style (pops everywhere) */
    .highlighted-preview.yellow-pop {
      fill: #ffff00 !important;
      filter: drop-shadow(0 0 6px #ffff0088);
    }

    text.highlighted-preview,
    .highlighted-preview text {
      fill: #00ffff !important;
      /* or your preferred vivid color */
      stroke: black !important;
      /* or #0008 for softer outline */
      stroke-width: 2.5px !important;
      /* 1.8–3.5 px depending on font-size */
      paint-order: stroke fill !important;
      /* stroke first = outline around letters */
      font-weight: bold !important;
    }

    /* Optional: white text + dark outline (very readable) */
    text.highlighted-preview.white-outline {
      fill: white !important;
      stroke: #000 !important;
      stroke-width: 3px !important;
      paint-order: stroke fill !important;
    }
  </style>
</head>

<body>
  <div id="app"></div>

  <script type="module">
    import { optimize } from 'https://cdn.jsdelivr.net/npm/svgo@4.0.0/dist/svgo.browser.min.js';

    // TypeScript-like implementation in JavaScript
    class SVGOptimizer {
      constructor() {
        this.originalSvg = '';
        this.optimizedSvg = '';
        this.editor = null;
        this.history = []; // Store history for undo/redo
        this.historyPointer = -1; // Pointer to current position in history
        this.maxHistory = 20; // Maximum number of history entries
        this.options = {
          precision: 1,
          removeTspan: true,
          removeStyling: true,
          removeGroups: false,
          customWidth: 100,
          customHeight: 100,
          useCustomDimensions: false,
          removeDefaultValues: true,
          removeFontFamily: false,
          removeFontSize: false,
          convertSodipodiArcs: true,
          groupSimilarElements: true,
          groupingMode: 'group', // 'group', 'remove', or 'none'
          viewMode: 'code', // 'code', 'tree'
          selectedElementPath: null, // JSON path or similar to track selected element
          treeDoc: null, // Parsed DOM for the Tree View
          isUpdatingFromTree: false // Flag to prevent redundant re-parsing
        };
        this.unitConversion = {
          'px': 1,
          'pt': 1.25,  // 1pt = 1.25px (1/72 inch * 96 px/inch)
          'pc': 15,    // 1pc = 12pt = 15px
          'mm': 3.7795275591, // 1mm = 96/25.4 px
          'cm': 37.795275591, // 1cm = 10mm
          'in': 96     // 1in = 96px
        };
        this.isRestoringHistory = false;
        // Initialize with empty state
        this.saveToHistory();

        // Ensure we start with proper history state
        this.historyPointer = 0;
      }

      async initializeEditor() {
        return new Promise((resolve) => {
          require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/vs' } });
          require(['vs/editor/editor.main'], () => {
            // Wait for the DOM element to be available
            const checkContainer = () => {
              const container = document.getElementById('editor');
              if (container) {

                monaco.languages.register({ id: 'xml' });
                monaco.languages.setLanguageConfiguration('xml', {
                  brackets: [['<', '>']],
                  autoClosingPairs: [
                    { open: '<', close: '>' },
                    { open: '"', close: '"' },
                    { open: "'", close: "'" }
                  ]
                });
                this.editor = monaco.editor.create(container, {
                  value: this.originalSvg || '<!-- Paste your SVG code here or load a file -->',
                  language: 'xml',
                  theme: 'vs-dark',
                  automaticLayout: true,
                  minimap: { enabled: false },
                  wordWrap: 'on'
                });

                this.editor.onDidChangeModelContent(() => {
                  this.originalSvg = this.editor.getValue();
                  this.optimizeSvg();
                  // Update tree doc to reflect the new optimized content
                  this.updateTreeDoc();
                  this.saveToHistory(); // Save to history after editing
                  m.redraw();
                });

                this.editorReady = true;
                // Save initial state after editor is initialized
                if (this.history.length === 0) {
                  this.saveToHistory();
                }
                m.redraw(); // Trigger a redraw when editor is ready
                resolve();
              } else {
                // If container not found, try again in 50ms
                setTimeout(checkContainer, 50);
              }
            };
            checkContainer();
          });
        });
      }

      loadFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          this.originalSvg = e.target.result;
          if (this.editor) {
            try {
              this.editor.setValue(this.originalSvg);
            } catch (err) {
              console.error('Failed to set editor value:', err);
              // Try to fix common SVG issues before setting
              try {
                // Try to sanitize the SVG by fixing common issues
                this.originalSvg = this.sanitizeSvg(this.originalSvg);
                this.editor.setValue(this.originalSvg);
              } catch (fixErr) {
                console.error('Failed to sanitize SVG:', fixErr);
                // Fall back to showing the SVG in a plain text modal
                alert('The SVG file contains formatting issues that cannot be displayed in the editor. Please try a different file.');
                return;
              }
            }
          } else {
            // If editor isn't ready yet, reinitialize it with the content
            setTimeout(() => {
              if (this.editor) {
                try {
                  this.editor.setValue(this.originalSvg);
                } catch (err) {
                  console.error('Failed to set editor value (delayed):', err);
                }
              }
            }, 100);
          }
          this.updateTreeDoc();
          this.optimizeSvg();

          // Always save to history after loading
          // First, trim history if we're not at the end
          if (this.historyPointer < this.history.length - 1) {
            // Trim history to current position
            this.history = this.history.slice(0, this.historyPointer + 1);
          }

          // Save current state to history
          this.saveToHistory();

          m.redraw();
        };
        reader.readAsText(file);
      }

      loadOptimizedFile() {
        if (this.optimizedSvg) {
          this.originalSvg = this.optimizedSvg;
          this.editor.setValue(this.originalSvg);
          // Update tree doc to reflect the optimized content
          this.updateTreeDoc();
        }
      }

      roundNumbers(str, precision) {
        // Updated regex to also match numbers starting with a decimal point (e.g., .1234)
        return str.replace(/(-?\d*\.\d+)/g, (match) => {
          const num = parseFloat(match);
          const absNum = Math.abs(num);
          let dynamicPrecision = precision;

          // Dynamic precision based on number magnitude
          if (absNum >= 100) {
            // Large numbers (≥100): can be rounded more aggressively
            dynamicPrecision = Math.max(0, precision - 2);
          } else if (absNum >= 10) {
            // Medium numbers (10-99): round slightly more aggressively
            dynamicPrecision = Math.max(0, precision - 1);
          } else if (absNum >= 1) {
            // Numbers 1-9: use normal precision
            dynamicPrecision = precision;
          } else {
            // Small numbers (<1): preserve more precision to avoid visual impact
            dynamicPrecision = Math.min(precision + 1, 5);
          }

          let rounded;

          if (dynamicPrecision === 0) {
            rounded = Math.round(num);
          } else {
            rounded = parseFloat(num.toFixed(dynamicPrecision));

            // If rounding would make the number zero, try with one more decimal place
            if (rounded === 0 && num !== 0) {
              rounded = parseFloat(num.toFixed(dynamicPrecision + 1));
            }
          }

          let result = rounded.toString();

          // Remove leading zero for numbers between -1 and 1 (e.g., 0.5 -> .5, -0.3 -> -.3)
          if (result.startsWith('0.')) {
            result = result.substring(1);
          } else if (result.startsWith('-0.')) {
            result = '-' + result.substring(2);
          }

          return result;
        });
      }

      removeTspanElements(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        // Remove all tspan elements but keep their text content
        const tspans = doc.querySelectorAll('tspan');
        tspans.forEach(tspan => {
          const parent = tspan.parentElement;
          if (parent) {
            // Move text content to parent
            if (tspan.textContent) {
              parent.insertBefore(doc.createTextNode(tspan.textContent), tspan);
            }
            parent.removeChild(tspan);
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      removeStyling(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        // Remove style elements
        const styles = doc.querySelectorAll('style');
        styles.forEach(style => style.remove());

        // Remove style attributes
        const allElements = doc.querySelectorAll('*');
        allElements.forEach(el => {
          el.removeAttribute('style');
          el.removeAttribute('class');
        });

        return new XMLSerializer().serializeToString(doc);
      }

      removeGroups(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        // Flatten groups by moving their children to parent
        const groups = Array.from(doc.querySelectorAll('g'));
        groups.forEach(group => {
          const parent = group.parentElement;
          if (parent) {
            // Move all children to parent
            while (group.firstChild) {
              parent.insertBefore(group.firstChild, group);
            }
            parent.removeChild(group);
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      removeDefaultValues(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        const defaultValues = {
          'letter-spacing': ['0', 'normal'],
          'word-spacing': ['0', 'normal'],
          'paint-order': ['normal', 'fill stroke markers', 'markers stroke fill'],
          'fill-opacity': ['1'],
          'stroke-opacity': ['1'],
          'opacity': ['1'],
          'clip-rule': ['nonzero'],
          'fill-rule': ['nonzero'],
          'stroke-miterlimit': ['4'],
          'stroke-linecap': ['butt'],
          'stroke-linejoin': ['miter', 'round'],
          'xml:space': ["preserve"],
          'font-weight': ["400"],
        };

        const allElements = doc.querySelectorAll('*');
        allElements.forEach(el => {
          Object.keys(defaultValues).forEach(attr => {
            const value = el.getAttribute(attr);
            if (value && defaultValues[attr].includes(value)) {
              el.removeAttribute(attr);
            }
          });

          // Special handling for opacity >= 0.9
          const opacityValue = el.getAttribute('opacity');
          if (opacityValue) {
            const opacity = parseFloat(opacityValue);
            if (opacity >= 0.9) {
              el.removeAttribute('opacity');
            }
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      removeFontAttributes(svg, removeFontFamily, removeFontSize) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        const allElements = doc.querySelectorAll('*');
        allElements.forEach(el => {
          if (removeFontFamily) {
            el.removeAttribute('font-family');
          }
          if (removeFontSize) {
            el.removeAttribute('font-size');
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      groupTextByAttributes(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');
        const SVG_NS = 'http://www.w3.org/2000/svg';

        // Find all text elements
        const textElements = Array.from(doc.querySelectorAll('text, tspan'));

        if (textElements.length < 2) return svg; // Need at least 2 elements to group

        // Attributes we want to group by
        const groupableAttributes = ['font-family', 'font-size', 'text-anchor', 'font-weight', 'font-style'];

        // Group text elements by their attribute signature
        const groups = new Map();

        textElements.forEach(el => {
          const attributes = {};
          let hasGroupableAttrs = false;

          groupableAttributes.forEach(attr => {
            const value = el.getAttribute(attr);
            if (value) {
              attributes[attr] = value;
              hasGroupableAttrs = true;
            }
          });

          // Only group elements that have at least one groupable attribute
          if (hasGroupableAttrs) {
            const signature = JSON.stringify(attributes);
            if (!groups.has(signature)) {
              groups.set(signature, { attributes, elements: [] });
            }
            groups.get(signature).elements.push(el);
          }
        });

        // Process groups with 2 or more elements
        groups.forEach(({ attributes, elements }) => {
          if (elements.length >= 2) {
            // Create a group element
            const group = doc.createElementNS(SVG_NS, 'g');

            // Add common attributes to the group
            Object.entries(attributes).forEach(([attr, value]) => {
              group.setAttribute(attr, value);
            });

            // Find a common parent for all elements in this group
            let commonParent = elements[0].parentNode;

            // Simple approach: use the parent of the first element
            // Insert the group before the first element
            commonParent.insertBefore(group, elements[0]);

            // Move elements to the group and remove their common attributes
            elements.forEach(el => {
              // Remove the common attributes from the element
              Object.keys(attributes).forEach(attr => {
                el.removeAttribute(attr);
              });

              // Move element to the group
              group.appendChild(el);
            });
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      groupSimilarElementsByType(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');
        const SVG_NS = 'http://www.w3.org/2000/svg';

        // Process different element types separately
        const elementTypes = ['path', 'circle', 'ellipse', 'rect', 'line', 'polyline', 'polygon'];

        elementTypes.forEach(tagName => {
          const elements = Array.from(doc.querySelectorAll(tagName));
          if (elements.length < 2) return;

          // Attributes that make sense to group for this element type
          const groupableAttributes = [
            'fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin',
            'stroke-dasharray', 'stroke-dashoffset', 'stroke-miterlimit',
            'fill-rule', 'opacity', 'fill-opacity', 'stroke-opacity'
          ];

          // Count frequency of each attribute-value pair
          const attributeValueCounts = new Map();

          elements.forEach(el => {
            groupableAttributes.forEach(attr => {
              const value = el.getAttribute(attr);
              if (value) {
                const key = `${attr}:${value}`;
                attributeValueCounts.set(key, (attributeValueCounts.get(key) || 0) + 1);
              }
            });
          });

          // Find attribute-value pairs that appear in 2+ elements
          const commonAttributeValues = new Map();
          attributeValueCounts.forEach((count, key) => {
            if (count >= 2) {
              const [attr, value] = key.split(':', 2);
              if (!commonAttributeValues.has(attr)) {
                commonAttributeValues.set(attr, new Map());
              }
              commonAttributeValues.get(attr).set(value, count);
            }
          });

          // For each attribute, find the most common value
          const mostCommonAttributes = {};
          commonAttributeValues.forEach((valueCounts, attr) => {
            let maxCount = 0;
            let mostCommonValue = null;
            valueCounts.forEach((count, value) => {
              if (count > maxCount) {
                maxCount = count;
                mostCommonValue = value;
              }
            });
            if (maxCount >= 2) {
              mostCommonAttributes[attr] = mostCommonValue;
            }
          });

          // If we have common attributes, create a group
          if (Object.keys(mostCommonAttributes).length > 0) {
            // Find elements that have these common attributes (they may have additional attributes)
            const elementsToGroup = elements.filter(el => {
              return Object.entries(mostCommonAttributes).every(([attr, value]) => {
                return el.getAttribute(attr) === value;
              });
            });

            if (elementsToGroup.length >= 2) {
              // Calculate if grouping saves space
              const attributeCount = Object.keys(mostCommonAttributes).length;
              const groupOverhead = 7; // <g></g> overhead
              const avgAttrSize = 15; // Average attribute size
              const savings = (elementsToGroup.length - 1) * attributeCount * avgAttrSize - groupOverhead;

              if (savings > 0) {
                // Create a group element
                const group = doc.createElementNS(SVG_NS, 'g');

                // Add common attributes to the group
                Object.entries(mostCommonAttributes).forEach(([attr, value]) => {
                  group.setAttribute(attr, value);
                });

                // Find a common parent for all elements in this group
                let commonParent = elementsToGroup[0].parentNode;

                // Insert the group before the first element
                commonParent.insertBefore(group, elementsToGroup[0]);

                // Move elements to the group and remove their common attributes
                elementsToGroup.forEach(el => {
                  // Remove only the common attributes from the element (keep unique ones)
                  Object.keys(mostCommonAttributes).forEach(attr => {
                    el.removeAttribute(attr);
                  });

                  // Move element to the group
                  group.appendChild(el);
                });
              }
            }
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      combinePaths(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');
        const SVG_NS = 'http://www.w3.org/2000/svg';

        const pathElements = Array.from(doc.querySelectorAll('path'));
        if (pathElements.length < 2) return svg;

        // Group paths by their attributes (excluding 'd')
        const pathGroups = new Map();

        pathElements.forEach(path => {
          const attributes = {};
          Array.from(path.attributes).forEach(attr => {
            if (attr.name !== 'd') {
              attributes[attr.name] = attr.value;
            }
          });

          const signature = JSON.stringify(attributes);
          if (!pathGroups.has(signature)) {
            pathGroups.set(signature, { attributes, paths: [] });
          }
          pathGroups.get(signature).paths.push(path);
        });

        // Combine paths with identical attributes
        pathGroups.forEach(({ attributes, paths }) => {
          if (paths.length >= 2) {
            // Combine d attributes
            const combinedD = paths.map(path => path.getAttribute('d')).join(' ');

            // Create new combined path
            const combinedPath = doc.createElementNS(SVG_NS, 'path');
            combinedPath.setAttribute('d', combinedD);

            // Add other attributes
            Object.entries(attributes).forEach(([attr, value]) => {
              combinedPath.setAttribute(attr, value);
            });

            // Replace first path with combined path
            const firstPath = paths[0];
            firstPath.parentNode.insertBefore(combinedPath, firstPath);

            // Remove original paths
            paths.forEach(path => path.remove());
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      removeStrokeFromText(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        // Find all text elements and remove stroke-related attributes
        const textElements = doc.querySelectorAll('text, tspan');
        textElements.forEach(el => {
          el.removeAttribute('stroke');
          el.removeAttribute('stroke-width');
          el.removeAttribute('stroke-opacity');
          el.removeAttribute('stroke-dasharray');
          el.removeAttribute('stroke-dashoffset');
          el.removeAttribute('stroke-linecap');
          el.removeAttribute('stroke-linejoin');
          el.removeAttribute('stroke-miterlimit');
        });

        return new XMLSerializer().serializeToString(doc);
      }

      removeDuplicateDefs(svg) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        const defsElement = doc.querySelector('defs');
        if (!defsElement) return svg;

        // Get all children of defs
        const defChildren = Array.from(defsElement.children);
        const defsByContent = new Map();
        const idMappings = new Map();

        defChildren.forEach(child => {
          // Create a normalized string representation of the element (without id)
          const childClone = child.cloneNode(true);
          childClone.removeAttribute('id');
          const normalized = new XMLSerializer().serializeToString(childClone);

          const originalId = child.getAttribute('id');

          if (defsByContent.has(normalized)) {
            // This is a duplicate - map its ID to the first occurrence's ID
            const firstId = defsByContent.get(normalized);
            idMappings.set(originalId, firstId);

            // Remove the duplicate element
            child.remove();
          } else {
            // This is the first occurrence
            defsByContent.set(normalized, originalId);
          }
        });

        // Update all references in the document
        if (idMappings.size > 0) {
          const svgString = new XMLSerializer().serializeToString(doc);
          let updatedSvg = svgString;

          idMappings.forEach((newId, oldId) => {
            // Replace url(#oldId) with url(#newId)
            updatedSvg = updatedSvg.replace(new RegExp(`url\\(#${oldId}\\)`, 'g'), `url(#${newId})`);
            // Replace #oldId with #newId in other contexts
            updatedSvg = updatedSvg.replace(new RegExp(`#${oldId}`, 'g'), `#${newId}`);
          });

          return updatedSvg;
        }

        return new XMLSerializer().serializeToString(doc);
      }

      convertSodipodiArcs(svg) {
        const SODIPODI_NS = 'http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd';
        const SVG_NS = 'http://www.w3.org/2000/svg';

        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');

        const sodipodiArcs = Array.from(doc.querySelectorAll('circle, ellipse')).filter(el =>
          el.getAttributeNS(SODIPODI_NS, 'type') === 'arc'
        );

        sodipodiArcs.forEach(arc => {
          try {
            const cx = parseFloat(arc.getAttributeNS(SODIPODI_NS, 'cx') || '0');
            const cy = parseFloat(arc.getAttributeNS(SODIPODI_NS, 'cy') || '0');
            let rx = parseFloat(arc.getAttributeNS(SODIPODI_NS, 'rx') || '0');
            let ry = parseFloat(arc.getAttributeNS(SODIPODI_NS, 'ry') || '0');
            let startAngle = parseFloat(arc.getAttributeNS(SODIPODI_NS, 'start') || '0');
            let endAngle = parseFloat(arc.getAttributeNS(SODIPODI_NS, 'end') || `${2 * Math.PI}`);

            // Ensure radii are positive
            rx = Math.abs(rx);
            ry = Math.abs(ry);

            if (rx <= 0 || ry <= 0) {
              console.warn('Skipping sodipodi arc with zero or negative radius:', arc);
              // Clean up sodipodi attributes even if not converted
              Array.from(arc.attributes).forEach(attr => {
                if (attr.name.startsWith('sodipodi:')) {
                  arc.removeAttribute(attr.name);
                }
              });
              return; // Skip this arc
            }

            // Normalize angles to be within [0, 2*PI)
            startAngle = startAngle % (2 * Math.PI);
            if (startAngle < 0) startAngle += 2 * Math.PI;
            endAngle = endAngle % (2 * Math.PI);
            if (endAngle < 0) endAngle += 2 * Math.PI;

            const epsilon = 1e-6; // Small value for float comparison

            // Check if it's a full circle (or very close to it) AND a perfect circle (rx == ry)
            const isFullCircle = (Math.abs(endAngle - startAngle) < epsilon || Math.abs(Math.abs(endAngle - startAngle) - 2 * Math.PI) < epsilon);
            const isPerfectCircle = Math.abs(rx - ry) < epsilon;

            let newElement;

            if (isFullCircle && isPerfectCircle) {
              // Convert to a <circle> element for full circles
              newElement = doc.createElementNS(SVG_NS, 'circle');
              newElement.setAttribute('cx', cx.toString());
              newElement.setAttribute('cy', cy.toString());
              newElement.setAttribute('r', rx.toString()); // For a circle, rx is the radius
            } else {
              // Convert to a <path> element for arcs/ellipses
              newElement = doc.createElementNS(SVG_NS, 'path');
              const pathData = this.createEllipticalArcPath(cx, cy, rx, ry, startAngle, endAngle);
              newElement.setAttribute('d', pathData);
            }

            // Copy all non-sodipodi attributes to the new element
            Array.from(arc.attributes).forEach(attr => {
              if (!attr.name.startsWith('sodipodi:') &&
                !(newElement.tagName === 'circle' && (attr.name === 'cx' || attr.name === 'cy' || attr.name === 'r')) &&
                !(newElement.tagName === 'path' && attr.name === 'd')) {
                newElement.setAttribute(attr.name, attr.value);
              }
            });

            arc.parentNode.replaceChild(newElement, arc);

          } catch (error) {
            console.warn('Failed to convert sodipodi arc:', error);
            // Even if conversion fails, remove sodipodi attributes to clean up the original element
            Array.from(arc.attributes).forEach(attr => {
              if (attr.name.startsWith('sodipodi:')) {
                arc.removeAttribute(attr.name);
              }
            });
          }
        });

        return new XMLSerializer().serializeToString(doc);
      }

      createEllipticalArcPath(cx, cy, rx, ry, startAngle, endAngle) {
        // Convert polar coordinates to Cartesian for start and end points
        const startX = cx + rx * Math.cos(startAngle);
        const startY = cy + ry * Math.sin(startAngle);
        const endX = cx + rx * Math.cos(endAngle);
        const endY = cy + ry * Math.sin(endAngle);

        // Calculate the difference in angles to determine large-arc-flag and sweep-flag
        // The direction for sodipodi is usually positive (counter-clockwise on standard cartesian plane,
        // which translates to clockwise in SVG's Y-down coordinate system if sweep-flag is 1).
        let angleDiff = endAngle - startAngle;
        if (angleDiff < 0) {
          angleDiff += 2 * Math.PI; // Normalize angle difference to be positive
        }

        // large-arc-flag: 1 if angleDiff > PI, 0 otherwise
        const largeArcFlag = angleDiff > Math.PI ? 1 : 0;

        // sweep-flag: 1 for clockwise (positive angle increase), 0 for counter-clockwise.
        // Given sodipodi's positive angle convention for 'end' relative to 'start',
        // and SVG's default y-axis going down, a positive angle increase in sodipodi
        // usually means a clockwise sweep in SVG for the most direct path.
        // If endAngle < startAngle initially, it implies a counter-clockwise sweep.
        // However, after normalization, we need to be careful.
        // The simplest way to think about it for sodipodi's convention:
        // If endAngle is 'after' startAngle in the positive direction (0 to 2PI), sweepFlag should be 1.
        // If endAngle is 'before' startAngle (meaning it wrapped around), sweepFlag should be 0.
        // After normalization, if endAngle > startAngle, we assume positive sweep (clockwise for SVG).
        // If startAngle > endAngle, it means we crossed the 0/2PI boundary, implying a "negative" sweep,
        // which in SVG typically means `sweepFlag=0` if `endAngle` is reached by going CCW from `startAngle`.

        // A simpler heuristic for sweepFlag, assuming sodipodi's 'start' and 'end' define the arc
        // in a positive (counter-clockwise) direction on a standard mathematical coordinate system.
        // SVG's Y-axis is inverted. So, a counter-clockwise arc in math becomes a clockwise arc in SVG
        // if sweep-flag is 1.
        const sweepFlag = 1; // Assuming positive angle rotation from sodipodi translates to clockwise in SVG

        return `M ${startX} ${startY} A ${rx} ${ry} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
      }

      // Helper to parse SVG length values (e.g., "10mm", "20px", "50")
      parseSvgLength(lengthStr, defaultVal = 0) {
        if (typeof lengthStr !== 'string') return defaultVal;

        const match = lengthStr.match(/^([\d.]+)([a-z]*)$/i);
        if (match) {
          const value = parseFloat(match[1]);
          const unit = match[2].toLowerCase() || 'px'; // Default to px if no unit

          if (this.unitConversion[unit]) {
            return value * this.unitConversion[unit];
          } else {
            // For unknown units, assume pixels if no unit is specified (e.g., "100")
            // If a unit is specified but unknown, it's safer to default to 0 or log a warning.
            console.warn(`Unknown SVG unit: "${unit}" in "${lengthStr}". Treating value as pixels.`);
            return value; // Treat as pixels if unit is unrecognized
          }
        }
        // If no unit or conversion factor, just try to parse as float (plain number)
        return parseFloat(lengthStr) || defaultVal;
      }

      /**
       * Calculates the bounding box of the SVG content within its current coordinate system.
       * This method requires a browser environment to function correctly as it relies on
       * SVG DOM methods like `getBBox()`.
       * @param {string} svgString The SVG content as a string.
       * @returns {object|null} An object with {x, y, width, height} or null if calculation fails.
       */
      calculateContentBBox(svgString) {
        // Create a temporary SVG element in a detached DOM fragment or hidden div
        const tempDiv = document.createElement('div');
        tempDiv.style.position = 'absolute';
        tempDiv.style.top = '-9999px';
        tempDiv.style.left = '-9999px';
        tempDiv.style.width = '0';
        tempDiv.style.height = '0';
        tempDiv.style.overflow = 'hidden';
        document.body.appendChild(tempDiv); // Append to body to make getBBox work

        tempDiv.innerHTML = svgString;
        const svgElement = tempDiv.querySelector('svg');

        if (!svgElement) {
          document.body.removeChild(tempDiv);
          console.error("No SVG element found in the provided string for BBox calculation.");
          return null;
        }

        try {
          // Get the bounding box of the entire SVG content
          // This method accounts for all visible elements.
          // It returns an SVGRect which has x, y, width, height.
          // Important: This can fail or return 0,0,0,0 if the SVG is empty or has no renderable content.
          const bbox = svgElement.getBBox();

          // Check if bbox is valid (not empty)
          if (bbox.width === 0 && bbox.height === 0 && bbox.x === 0 && bbox.y === 0) {
            // This might indicate an empty SVG or elements with no rendering area.
            // Fallback to parsing viewBox or width/height if getBBox is effectively zero.
            // Or, if content is truly empty, return null.
            console.warn("getBBox returned an empty bounding box. Trying to derive from SVG attributes.");
            let currentWidth, currentHeight, minX = 0, minY = 0;
            let viewBoxAttr = svgElement.getAttribute('viewBox');
            if (viewBoxAttr) {
              const vbParts = viewBoxAttr.split(/\s+/).map(Number);
              minX = vbParts[0] || 0;
              minY = vbParts[1] || 0;
              currentWidth = vbParts[2] || 0;
              currentHeight = vbParts[3] || 0;
            } else {
              currentWidth = this.parseSvgLength(svgElement.getAttribute('width'), 0);
              currentHeight = this.parseSvgLength(svgElement.getAttribute('height'), 0);
            }

            if (currentWidth > 0 && currentHeight > 0) {
              return { x: minX, y: minY, width: currentWidth, height: currentHeight };
            } else {
              console.error("Could not determine content bounding box from getBBox or SVG attributes.");
              return null;
            }
          }

          return {
            x: bbox.x,
            y: bbox.y,
            width: bbox.width,
            height: bbox.height
          };
        } catch (e) {
          console.error("Error calculating SVG bounding box:", e);
          return null;
        } finally {
          document.body.removeChild(tempDiv); // Clean up the temporary element
        }
      }

      /**
       * Resizes an SVG by adjusting its viewBox and width/height attributes
       * to fit the content into a new canvas size while preserving aspect ratio.
       * @param {string} svg The SVG content as a string.
       * @param {number} newWidth The desired new width in pixels.
       * @param {number} newHeight The desired new height in pixels.
       * @returns {string} The resized SVG string.
       */
      resizeSvg(svg, newWidth, newHeight) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svg, 'image/svg+xml');
        const svgElement = doc.documentElement;

        if (svgElement.tagName !== 'svg') {
          console.error("The provided SVG string does not contain an SVG element as its root.");
          return svg;
        }

        const contentBBox = this.calculateContentBBox(svg);

        let finalViewBoxX, finalViewBoxY, finalViewBoxWidth, finalViewBoxHeight;

        if (contentBBox && contentBBox.width > 0 && contentBBox.height > 0) {
          // Apply flooring to x and y, and ceiling to the max x/y to ensure full visibility
          const x1 = Math.floor(contentBBox.x);
          const y1 = Math.floor(contentBBox.y);
          const x2 = Math.ceil(contentBBox.x + contentBBox.width);
          const y2 = Math.ceil(contentBBox.y + contentBBox.height);

          finalViewBoxX = x1;
          finalViewBoxY = y1;
          finalViewBoxWidth = x2 - x1;
          finalViewBoxHeight = y2 - y1;

          // Handle potential edge case where width/height might become 0 after rounding
          if (finalViewBoxWidth === 0 && contentBBox.width > 0) {
            finalViewBoxWidth = 1;
          }
          if (finalViewBoxHeight === 0 && contentBBox.height > 0) {
            finalViewBoxHeight = 1;
          }

        } else {
          console.warn("Could not calculate content BBox reliably. Falling back to existing viewBox or a default.");
          let currentWidth, currentHeight, minX = 0, minY = 0;
          let viewBoxAttr = svgElement.getAttribute('viewBox');

          if (viewBoxAttr) {
            const vbParts = viewBoxAttr.split(/\s+/).map(Number);
            minX = Math.floor(vbParts[0] || 0);
            minY = Math.floor(vbParts[1] || 0);
            currentWidth = Math.ceil(vbParts[2] || 0); // Round up width/height
            currentHeight = Math.ceil(vbParts[3] || 0);
          } else {
            minX = 0;
            minY = 0;
            currentWidth = Math.ceil(this.parseSvgLength(svgElement.getAttribute('width'), 100));
            currentHeight = Math.ceil(this.parseSvgLength(svgElement.getAttribute('height'), 100));
          }

          finalViewBoxX = minX;
          finalViewBoxY = minY;
          finalViewBoxWidth = currentWidth;
          finalViewBoxHeight = currentHeight;

          if (finalViewBoxWidth <= 0 || finalViewBoxHeight <= 0) {
            console.error("Failed to determine a valid content area for resizing. Using a default 0 0 100 100 viewBox.");
            finalViewBoxX = 0;
            finalViewBoxY = 0;
            finalViewBoxWidth = 100;
            finalViewBoxHeight = 100;
          }
        }

        // Set the new width and height for the SVG element
        svgElement.setAttribute('width', newWidth.toString());
        svgElement.setAttribute('height', newHeight.toString());

        // Set the viewBox with integer coordinates
        svgElement.setAttribute('viewBox', `${finalViewBoxX} ${finalViewBoxY} ${finalViewBoxWidth} ${finalViewBoxHeight}`);

        // preserveAspectRatio remains default 'xMidyMid meet' unless specified otherwise.

        return new XMLSerializer().serializeToString(doc);
      }

      sanitizeSvg(svg) {
        if (!svg || typeof svg !== 'string') return svg;

        try {
          // Try to parse and validate the SVG
          const parser = new DOMParser();
          const doc = parser.parseFromString(svg, 'image/svg+xml');
          const parseError = doc.querySelector('parsererror');
          if (parseError) {
            console.warn('SVG parsing error:', parseError.textContent);
            // Try to fix common issues
            svg = this.fixCommonSvgIssues(svg);
          }
        } catch (e) {
          console.warn('SVG sanitization failed, using original:', e);
        }
        return svg;
      }

      fixCommonSvgIssues(svg) {
        // Try to fix common SVG issues
        let fixed = svg;

        // Fix malformed path data - handle missing numbers after operators
        // Pattern: ...124 6.8 18-12.51Z (where 18-12.51 should be separate numbers)
        fixed = fixed.replace(/(\d+)-(\d+(\.\d+)?)/g, '$1 $2');

        // Fix common encoding issues
        fixed = fixed.replace(/&gt;/g, '>');
        fixed = fixed.replace(/&lt;/g, '<');
        fixed = fixed.replace(/&amp;/g, '&');
        fixed = fixed.replace(/&quot;/g, '"');
        fixed = fixed.replace(/&apos;/g, "'");

        // Fix common whitespace issues
        fixed = fixed.replace(/>\s+</g, '><');

        return fixed;
      }

      updateTreeDoc() {
        if (!this.originalSvg) {
          this.options.treeDoc = null;
          return;
        }
        const parser = new DOMParser();
        // Use optimizedSvg for tree view if available, otherwise fall back to originalSvg
        const svgToParse = this.optimizedSvg || this.originalSvg;
        this.options.treeDoc = parser.parseFromString(svgToParse, 'image/svg+xml');
      }

      async optimizeSvg() {
        if (!this.originalSvg.trim()) {
          this.optimizedSvg = '';
          return;
        }

        try {
          let svg = this.originalSvg;

          // Convert sodipodi arcs BEFORE SVGO to prevent removal
          if (this.options.convertSodipodiArcs) {
            svg = this.convertSodipodiArcs(svg);
          }

          // First pass with SVGO
          const svgoResult = optimize(svg, {
            plugins: [
              "preset-default",
              'removeDoctype',
              'removeXMLProcInst',
              'removeComments',
              'removeMetadata',
              'removeTitle',
              'removeDesc',
              'removeUselessDefs',
              'removeEditorsNSData',
              'removeEmptyAttrs',
              'removeHiddenElems',
              'removeEmptyText',
              'removeEmptyContainers',
              'removeViewBox',
              'cleanupEnableBackground',
              'convertStyleToAttrs',
              'convertColors',
              'convertPathData',
              'convertTransform',
              'removeUnknownsAndDefaults',
              'removeNonInheritableGroupAttrs',
              'removeUselessStrokeAndFill',
              'removeUnusedNS',
              'cleanupIds',
              'cleanupNumericValues',
              'moveElemsAttrsToGroup',
              'moveGroupAttrsToElems',
              'collapseGroups',
              'removeRasterImages',
              'mergePaths',
              'convertShapeToPath',
              'sortAttrs',
              'removeDimensions'
            ]
          });

          svg = svgoResult.data;

          // Apply custom optimizations
          if (this.options.precision >= 0) {
            svg = this.roundNumbers(svg, this.options.precision);
          }

          if (this.options.removeDefaultValues) {
            svg = this.removeDefaultValues(svg);
          }

          if (this.options.removeFontFamily || this.options.removeFontSize) {
            svg = this.removeFontAttributes(svg, this.options.removeFontFamily, this.options.removeFontSize);
          }

          if (this.options.removeTspan) {
            svg = this.removeTspanElements(svg);
          }

          if (this.options.removeStyling) {
            svg = this.removeStyling(svg);
          }

          // Handle grouping based on mode
          if (this.options.groupingMode === 'remove') {
            svg = this.removeGroups(svg);
          } else if (this.options.groupingMode === 'group') {
            // Group similar elements only (disable aggressive path combining for now)
            svg = this.groupSimilarElementsByType(svg);
            // Note: combinePaths disabled as it's too aggressive
            // svg = this.combinePaths(svg);
          }

          // Remove duplicate definitions
          svg = this.removeDuplicateDefs(svg);

          // Remove stroke attributes from text elements
          svg = this.removeStrokeFromText(svg);

          // Group text elements by common attributes (always enabled for text optimization)
          svg = this.groupTextByAttributes(svg);

          if (this.options.useCustomDimensions) {
            svg = this.resizeSvg(svg, this.options.customWidth, this.options.customHeight);
          }

          this.optimizedSvg = svg;
        } catch (error) {
          console.error('Optimization error:', error);
          this.optimizedSvg = `<!-- Error optimizing SVG: ${error.message} -->\n${this.originalSvg}`;
        }
      }

      downloadSvg() {
        if (!this.optimizedSvg) return;

        const blob = new Blob([this.optimizedSvg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'optimized.svg';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      getStats() {
        const originalSize = new Blob([this.originalSvg]).size;
        const optimizedSize = new Blob([this.optimizedSvg]).size;
        const reduction = originalSize - optimizedSize;
        const reductionPercent = originalSize > 0 ? ((reduction / originalSize) * 100) : 0;

        return {
          originalSize,
          optimizedSize,
          reduction,
          reductionPercent
        };
      }

      formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
      }

      // History management methods
      saveToHistory() {
        if (this.isRestoringHistory) return;

        if (this.historyPointer < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyPointer + 1);
        }

        this.history.push({
          originalSvg: this.originalSvg,
          optimizedSvg: this.optimizedSvg,
          options: { ...this.options }
        });

        if (this.history.length > this.maxHistory) {
          this.history.shift();
        }

        this.historyPointer = this.history.length - 1;
        m.redraw();
      }


      canUndo() {
        return this.historyPointer > 0;
      }

      canRedo() {
        return this.historyPointer < this.history.length - 1;
      }

      undo() {
        if (!this.canUndo()) return;

        this.isRestoringHistory = true;
        this.historyPointer--;

        const state = this.history[this.historyPointer];
        this.originalSvg = state.originalSvg;
        this.optimizedSvg = state.optimizedSvg;
        this.options = { ...state.options };

        if (this.editor) {
          this.editor.setValue(this.originalSvg);
        }

        this.updateTreeDoc();
        this.isRestoringHistory = false;
        m.redraw();
      }

      redo() {
        if (!this.canRedo()) return;

        this.isRestoringHistory = true;
        this.historyPointer++;

        const state = this.history[this.historyPointer];
        this.originalSvg = state.originalSvg;
        this.optimizedSvg = state.optimizedSvg;
        this.options = { ...state.options };

        if (this.editor) {
          this.editor.setValue(this.originalSvg);
        }

        this.updateTreeDoc();
        this.isRestoringHistory = false;
        m.redraw();
      }
    }

    const optimizer = new SVGOptimizer();

    const TreeView = {
      view() {
        if (!optimizer.originalSvg) return m('.tree-view', 'No SVG loaded');
        // Always update tree doc to ensure it reflects current state
        optimizer.updateTreeDoc();

        const svg = optimizer.options.treeDoc.querySelector('svg');

        if (!svg) return m('.tree-view', 'Invalid SVG');

        return m('.tree-view', [
          m('.tree-content', [
            m(TreeNode, { node: svg, path: '0', isRoot: true, prefix: '', isLast: true })
          ])
        ]);
      }
    };

    let dragSourcePath = null;
    let dragOverPath = null;

    // Uncontrolled Input Component to prevent Mithril redraws from interfering with typing
    const UncontrolledInput = {
      oncreate({ dom, attrs }) {
        dom.value = attrs.value;
        dom.size = Math.max(1, Math.min(20, dom.value.length));

        dom.addEventListener('keydown', (e) => {
          e.stopPropagation();
          if (e.key === 'Escape') {
            dom.value = attrs.value;
            dom.blur();
          }
          if (e.key === 'Enter') {
            dom.blur();
          }
        });

        dom.addEventListener('input', (e) => {
          e.target.size = Math.max(1, Math.min(20, e.target.value.length));
        });

        dom.addEventListener('change', (e) => {
          attrs.type = 'change'; // Signal change
          if (dom.value !== attrs.value) {
            attrs.onChange(dom.value);
          }
        });
      },
      onupdate({ dom, attrs }) {
        // Only update value from model if we are NOT currently editing/focused
        if (document.activeElement !== dom) {
          dom.value = attrs.value;
          dom.size = Math.max(1, Math.min(20, dom.value.length));
        }
      },
      view({ attrs }) {
        return m('input.attr-value');
      }
    };

    const TreeNode = {
      view({ attrs }) {
        const { node, path, isRoot, prefix, isLast } = attrs;
        if (node.nodeType !== 1) return null;

        const isSelected = optimizer.options.selectedElementPath === path;

        // For text and tspan elements, we want to include both children and text content
        let children = [];
        if (node.tagName === 'text' || node.tagName === 'tspan') {
          // Include both regular children and text nodes
          const allNodes = Array.from(node.childNodes);
          children = allNodes.filter(n => n.nodeType === 1 || (n.nodeType === 3 && n.textContent.trim() !== ''));
        } else {
          // For other elements, just use regular children
          children = Array.from(node.children);
        }

        const currentPrefix = prefix;
        const childPrefix = prefix + (isLast ? '   ' : '│  ');
        const ornament = isRoot ? '' : (isLast ? '└─ ' : '├─ ');

        return m('.tree-node-wrapper',
          [
            m('.tree-node-header', {
              id: `node-${path.replace(/\./g, '-')}`,
              class: `${isSelected ? 'selected' : ''} ${dragOverPath === path ? 'drag-over' : ''}`,
              draggable: !isRoot,
              ondragstart: (e) => {
                dragSourcePath = path;
                e.dataTransfer.setData('text/plain', path);
                e.stopPropagation();
              },
              ondragover: (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragOverPath = path;
              },
              ondragleave: () => {
                if (dragOverPath === path) dragOverPath = null;
              },
              ondrop: (e) => {
                e.preventDefault();
                e.stopPropagation();
                const sourcePath = e.dataTransfer.getData('text/plain');
                if (sourcePath && sourcePath !== path) {
                  moveElementTo(sourcePath, path);
                }
                dragOverPath = null;
                dragSourcePath = null;
              },
              onclick: (e) => {
                e.stopPropagation();
                optimizer.options.selectedElementPath = path;
                highlightElement(path);
                m.redraw();
              }
            }, [
              m('span.tree-prefix', currentPrefix + ornament),
              m('span.tag-name', node.tagName),
              m('.attributes', Array.from(node.attributes).map(attr =>
                m('.attribute', [
                  m('span.attr-name', attr.name),
                  m('span', '='),
                  m('.attr-value-container', [
                    m(UncontrolledInput, {
                      value: attr.value,
                      onChange: (newValue) => {
                        node.setAttribute(attr.name, newValue);
                        updateFromTree(node.ownerDocument);
                      }
                    }),
                    attr.value.length > 50 && m('.attr-value-full', attr.value)
                  ])
                ])
              )),
              m('.node-controls', [
                !isRoot && m('button.control-btn', {
                  onclick: (e) => {
                    e.stopPropagation();
                    moveElement(path, -1);
                  }
                }, '↑'),
                !isRoot && m('button.control-btn', {
                  onclick: (e) => {
                    e.stopPropagation();
                    moveElement(path, 1);
                  }
                }, '↓'),
                m('button.control-btn', {
                  style: 'color: #f44336;',
                  onclick: (e) => {
                    e.stopPropagation();
                    if (confirm(`Delete <${node.tagName}>?`)) {
                      node.remove();
                      updateFromTree(node.ownerDocument);
                    }
                  }
                }, '×')
              ])
            ]),
            m('.tree-node-children', children.map((child, index) => {
              // For text nodes, create a special representation
              if (child.nodeType === 3) {
                // Text node - create a special TreeNode-like representation
                const isLastChild = index === children.length - 1;
                const textOrnament = isLastChild ? '└─ ' : '├─ ';
                const textPath = `${path}.[-${index + 1}]`;
                return m('.tree-node-wrapper', [
                  m('.tree-node-header', {
                    class: 'text-node',
                    style: 'color: #9cdcfe;',
                    oncreate: (vnode) => {
                      vnode.dom.onclick = (e) => {
                        e.stopPropagation();
                        console.log('Text node clicked:', { path: textPath, child });
                        optimizer.options.selectedElementPath = textPath;
                        highlightElement(textPath);
                        m.redraw();
                      };
                    }
                  }, [
                    m('span.tree-prefix', childPrefix + textOrnament),
                    m('span.tag-name', '[Text Node]'),
                    m('.attributes', [
                      m('.attribute', [
                        m('span.attr-name', 'content'),
                        m('span', '='),
                        m('.attr-value-container', [
                          m(UncontrolledInput, {
                            value: child.textContent,
                            onChange: (newValue) => {
                              child.textContent = newValue;
                              updateFromTree(node.ownerDocument);
                            }
                          }),
                          child.textContent.length > 50 && m('.attr-value-full', child.textContent)
                        ])
                      ])
                    ])
                  ])
                ]);
              } else {
                // Regular element child
                return m(TreeNode, {
                  node: child,
                  path: `${path}.${index}`,
                  prefix: childPrefix,
                  isLast: index === children.length - 1,
                });
              }
            }))
          ]);
      }
    };

    function updateFromTree(doc) {
      optimizer.options.isUpdatingFromTree = true;
      optimizer.originalSvg = new XMLSerializer().serializeToString(doc);
      if (optimizer.editor) {
        optimizer.editor.setValue(optimizer.originalSvg);
      }
      optimizer.optimizeSvg();
      optimizer.options.isUpdatingFromTree = false;
      m.redraw();
    }

    function moveElementTo(sourcePath, targetPath) {
      if (sourcePath === targetPath) return;

      const doc = optimizer.options.treeDoc;
      const source = getElementByPath(doc, sourcePath);
      const target = getElementByPath(doc, targetPath);

      if (source && target) {
        const targetParent = target.parentElement;

        if (target.tagName === 'g' || target.tagName === 'svg') {
          target.insertBefore(source, target.firstChild);
        } else if (targetParent) {
          targetParent.insertBefore(source, target);
        }

        updateFromTree(doc);
      }
    }

    function moveElement(path, direction) {
      const doc = optimizer.options.treeDoc;
      const element = getElementByPath(doc, path);

      if (element && element.parentElement) {
        const parent = element.parentElement;
        const index = Array.from(parent.children).indexOf(element);
        const newIndex = index + direction;

        if (newIndex >= 0 && newIndex < parent.children.length) {
          if (direction === -1) {
            parent.insertBefore(element, parent.children[newIndex]);
          } else {
            parent.insertBefore(element, parent.children[newIndex].nextSibling);
          }

          const pathParts = path.split('.');
          pathParts[pathParts.length - 1] = newIndex;
          optimizer.options.selectedElementPath = pathParts.join('.');

          updateFromTree(doc);
        }
      }
    }

    function getElementByPath(doc, path) {
      const parts = path.split('.');
      let current = doc.querySelector('svg');
      if (parts[0] !== '0') return null;
      if (parts.length === 1) return current;

      for (let i = 1; i < parts.length; i++) {
        const index = parseInt(parts[i]);
        current = current.children[index];
        if (!current) return null;
      }
      return current;
    }

    function highlightElement(path) {
      console.log('highlightElement called with:', path);
      const previewContainer = document.querySelector('.preview-container');
      const previewSvg = previewContainer.querySelector('svg');
      if (!previewSvg) {
        console.log('No preview SVG found!');
        return;
      }

      previewSvg.querySelectorAll('.highlighted-preview').forEach(el => el.classList.remove('highlighted-preview'));

      const targetEl = getElementInSvgByPath(previewSvg, path);
      console.log('Target element:', targetEl);

      if (targetEl && targetEl.getBBox) {
        try {
          targetEl.classList.add('highlighted-preview');
          console.log('Element highlighted');
        } catch (e) {
          console.warn('Could not highlight element:', e);
        }
      } else {
        console.log('Could not highlight element: targetEl not found or no getBBox');
      }
    }

    function getElementInSvgByPath(svg, path) {
      const parts = path.split('.');
      let current = svg;
      if (parts[0] !== '0') {
        console.log('Invalid root:', path);
        return null;
      }

      console.log('Traversing path:', path, 'parts:', parts);

      for (let i = 1; i < parts.length; i++) {
        const indexStr = parts[i];
        console.log('  Part', i, ':', indexStr);

        // Handle array format for text nodes: [-1], [-2], etc.
        const arrayMatch = indexStr.match(/^\[-(\d+)\]$/);
        if (arrayMatch) {
          const textIndex = parseInt(arrayMatch[1]) - 1; // Convert to 0-based index
          console.log('  Found text node index:', textIndex);
          // Find the text node at this index
          const children = Array.from(current.childNodes);
          const textNodes = children.filter(n => n.nodeType === 3);
          console.log('  Total text nodes:', textNodes.length, 'textIndex:', textIndex);
          if (textNodes.length > textIndex) {
            current = textNodes[textIndex];
            console.log('  Text node found:', current.textContent.substring(0, 20) + '...');
          } else {
            console.log('  Text node not found!');
            return null;
          }
          continue;
        }

        let index = parseInt(indexStr);

        // Handle negative indices for text nodes
        if (index < 0) {
          // Find the text node at this index
          const children = Array.from(current.childNodes);
          const textNodes = children.filter(n => n.nodeType === 3);
          if (textNodes.length >= Math.abs(index)) {
            current = textNodes[Math.abs(index)];
          } else {
            return null;
          }
        } else {
          current = current.children[index];
          if (!current) {
            console.log('  Element not found at index:', index, 'total children:', current.children.length);
            return null;
          }
        }
      }
      console.log('Final element:', current.tagName || '[Text Node]');
      return current;
    }


    const App = {
      oncreate() {
        setTimeout(() => {
          optimizer.initializeEditor();
        }, 100);

        // Set up drag and drop
        const dropZone = document.body;
        dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
          dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const files = e.dataTransfer.files;
          if (files.length > 0 && files[0].type === 'image/svg+xml') {
            optimizer.loadFile(files[0]);
          }
        });
      },

      view() {
        const stats = optimizer.getStats();

        return m('div', [
          m('.header', [
            m('.title', [
              m('img.logo', { src: 'logo.svg', alt: 'Logo' }),
              m('span', 'Advanced SVG Optimizer')
            ]),
            m('.stats', [
              m('.stat', [
                m('.stat-label', 'Original'),
                m('.stat-value', optimizer.formatBytes(stats.originalSize))
              ]),
              m('.stat', [
                m('.stat-label', 'Optimized'),
                m('.stat-value', optimizer.formatBytes(stats.optimizedSize))
              ]),
              m('.stat', [
                m('.stat-label', 'Reduction'),
                m('.stat-value', {
                  class: stats.reduction > 0 ? 'reduction-positive' : stats.reduction < 0 ? 'reduction-negative' : ''
                }, `${stats.reduction > 0 ? '-' : ''}${optimizer.formatBytes(Math.abs(stats.reduction))} (${stats.reductionPercent.toFixed(1)}%)`)
              ])
            ])
          ]),

          m('.controls', [
            m('.file-input', [
              m('input[type=file]', {
                id: 'file-input',
                accept: '.svg,image/svg+xml',
                onchange: (e) => {
                  if (e.target.files[0]) {
                    optimizer.loadFile(e.target.files[0]);
                  }
                }
              })
            ]),
            m('label.file-button', { for: 'file-input' }, 'Open SVG File'),
            m('button[type=button][title=Load optimized SVG in editor]', {
              disabled: optimizer.optimizedSvg && optimizer.optimizedSvg.length > 0 ? undefined : 'disabled',
              onclick: () => optimizer.loadOptimizedFile(),
            }, 'Optimize'),
            m('button[type=button][title=Undo]', {
              disabled: !optimizer.canUndo(),
              onclick: () => {
                optimizer.undo();
                m.redraw();
              },
            },
              m('svg[fill=none][viewBox=0 0 24 24][width=20][height=20]',
                m('path[stroke=#000][stroke-linecap=round][stroke-width=2.5][d=M21 14c-.84-1.6-2.3-3-4.1-3.9a11 11 0 0 0-5.9-.96c-3.3.41-5.6 2.6-8.2 4.6m0-4.6v4.9h4.9]')
              ),

            ),
            m('button[type=button][title=Redo].svg', {
              disabled: !optimizer.canRedo(),
              onclick: () => {
                optimizer.redo();
                m.redraw();
              },
            },
              m('svg[fill=none][viewBox=0 0 24 24][width=20][height=20]',
                m('path[stroke=#000][stroke-linecap=round][stroke-width=2.5][d=M3.1 14c.84-1.6 2.3-3 4.1-3.9a11 11 0 0 1 5.9-.96c3.3.41 5.6 2.6 8.2 4.6m0-4.6v4.9H16]')
              ),
            ),

            m('.option-group', [
              m('.checkbox-group', [
                m('label', 'Precision:'),
                m('input.number-input[type=number]', {
                  value: optimizer.options.precision,
                  min: 0,
                  max: 5,
                  onchange: (e) => {
                    optimizer.options.precision = parseInt(e.target.value);
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
              ]),

              m('.checkbox-group', [
                m('input[type=checkbox]', {
                  id: 'convert-sodipodi',
                  checked: optimizer.options.convertSodipodiArcs,
                  onchange: (e) => {
                    optimizer.options.convertSodipodiArcs = e.target.checked;
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
                m('label', { for: 'convert-sodipodi' }, 'Convert sodipodi arcs')
              ]),

              m('.checkbox-group', [
                m('input[type=checkbox]', {
                  id: 'remove-defaults',
                  checked: optimizer.options.removeDefaultValues,
                  onchange: (e) => {
                    optimizer.options.removeDefaultValues = e.target.checked;
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
                m('label', { for: 'remove-defaults' }, 'Remove default values')
              ]),

              m('.checkbox-group', [
                m('input[type=checkbox]', {
                  id: 'remove-font-family',
                  checked: optimizer.options.removeFontFamily,
                  onchange: (e) => {
                    optimizer.options.removeFontFamily = e.target.checked;
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
                m('label', { for: 'remove-font-family' }, 'Remove font-family')
              ]),

              m('.checkbox-group', [
                m('input[type=checkbox]', {
                  id: 'remove-font-size',
                  checked: optimizer.options.removeFontSize,
                  onchange: (e) => {
                    optimizer.options.removeFontSize = e.target.checked;
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
                m('label', { for: 'remove-font-size' }, 'Remove font-size')
              ]),

              m('.checkbox-group', [
                m('input[type=checkbox]', {
                  id: 'remove-tspan',
                  checked: optimizer.options.removeTspan,
                  onchange: (e) => {
                    optimizer.options.removeTspan = e.target.checked;
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
                m('label', { for: 'remove-tspan' }, 'Remove tspan')
              ]),

              m('.checkbox-group', [
                m('input[type=checkbox]', {
                  id: 'remove-styling',
                  checked: optimizer.options.removeStyling,
                  onchange: (e) => {
                    optimizer.options.removeStyling = e.target.checked;
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
                m('label', { for: 'remove-styling' }, 'Remove styling')
              ]),

              m('.checkbox-group', [
                m('label', { style: 'margin-right: 1rem; font-weight: 600;' }, 'Grouping:'),
                m('input[type=radio]', {
                  id: 'grouping-none',
                  name: 'grouping-mode',
                  value: 'none',
                  checked: optimizer.options.groupingMode === 'none',
                  onchange: (e) => {
                    if (e.target.checked) {
                      optimizer.options.groupingMode = 'none';
                      optimizer.options.removeGroups = false;
                      optimizer.options.groupSimilarElements = false;
                      optimizer.optimizeSvg();
                      optimizer.saveToHistory();
                    }
                  }
                }),
                m('label', { for: 'grouping-none', style: 'margin-right: 1rem;' }, 'None'),

                m('input[type=radio]', {
                  id: 'grouping-group',
                  name: 'grouping-mode',
                  value: 'group',
                  checked: optimizer.options.groupingMode === 'group',
                  onchange: (e) => {
                    if (e.target.checked) {
                      optimizer.options.groupingMode = 'group';
                      optimizer.options.removeGroups = false;
                      optimizer.options.groupSimilarElements = true;
                      optimizer.optimizeSvg();
                      optimizer.saveToHistory();
                    }
                  }
                }),
                m('label', { for: 'grouping-group', style: 'margin-right: 1rem;' }, 'Group similar'),

                m('input[type=radio]', {
                  id: 'grouping-remove',
                  name: 'grouping-mode',
                  value: 'remove',
                  checked: optimizer.options.groupingMode === 'remove',
                  onchange: (e) => {
                    if (e.target.checked) {
                      optimizer.options.groupingMode = 'remove';
                      optimizer.options.removeGroups = true;
                      optimizer.options.groupSimilarElements = false;
                      optimizer.optimizeSvg();
                      optimizer.saveToHistory();
                    }
                  }
                }),
                m('label', { for: 'grouping-remove' }, 'Remove groups')
              ]),

              m('.checkbox-group', [
                m('input[type=checkbox]', {
                  id: 'custom-dimensions',
                  checked: optimizer.options.useCustomDimensions,
                  onchange: (e) => {
                    optimizer.options.useCustomDimensions = e.target.checked;
                    optimizer.optimizeSvg();
                    optimizer.saveToHistory();
                  }
                }),
                m('label', { for: 'custom-dimensions' }, 'Custom size:'),
                m('input.dimension-input[type=number]', {
                  value: optimizer.options.customWidth,
                  placeholder: 'Width',
                  onchange: (e) => {
                    optimizer.options.customWidth = parseInt(e.target.value);
                    if (optimizer.options.useCustomDimensions) {
                      optimizer.optimizeSvg();
                      optimizer.saveToHistory();
                    }
                  }
                }),
                m('span', '×'),
                m('input.dimension-input[type=number]', {
                  value: optimizer.options.customHeight,
                  placeholder: 'Height',
                  onchange: (e) => {
                    optimizer.options.customHeight = parseInt(e.target.value);
                    if (optimizer.options.useCustomDimensions) {
                      optimizer.optimizeSvg();
                      optimizer.saveToHistory();
                    }
                  }
                })
              ])
            ])
          ]),


          m('.main-content', {
            oncreate: () => {
              const splitter = document.getElementById('dragbar');
              const left = document.getElementById('left-panel');
              const right = document.getElementById('right-panel');
              splitter.onmousedown = function (e) {
                e.preventDefault();
                document.onmousemove = function (e) {
                  let percent = (e.clientX / (window.innerWidth)) * 100;
                  let percentSplitter = 6 / window.innerWidth * 100;
                  percent = Math.max(10, Math.min(90, percent));
                  left.style.flex = `0 0 ${percent}%`;
                  right.style.flex = `0 0 ${100 - percent - percentSplitter}%`;
                };
                document.onmouseup = function () {
                  document.onmousemove = null;
                  document.onmouseup = null;
                };
              };
            }
          }, [
            m('.editor-panel#left-panel', [

              m('.editor-panel', [
                m('.panel-header', [
                  m('span', 'Source SVG'),
                  optimizer.originalSvg ? m('span', `${optimizer.originalSvg.split('\n').length} lines`) : null,
                  m('div', { style: 'display: flex; gap: 0.5rem;' }, [
                    m('button', {
                      style: `background: ${optimizer.options.viewMode === 'code' ? '#4fc3f7' : '#444'}; font-size: 0.8rem; padding: 0.2rem 0.6rem;`,
                      onclick: () => optimizer.options.viewMode = 'code'
                    }, 'Code'),
                    m('button', {
                      style: `background: ${optimizer.options.viewMode === 'tree' ? '#4fc3f7' : '#444'}; font-size: 0.8rem; padding: 0.2rem 0.6rem;`,
                      onclick: () => optimizer.options.viewMode = 'tree'
                    }, 'Tree'),
                    m('button', {
                      style: 'background: #444; font-size: 0.8rem; padding: 0.2rem 0.6rem; cursor: pointer; border: none; border-radius: 4px; color: #e0e0e0; display: flex; align-items: center; gap: 0.3rem;',
                      onclick: () => copyToClipboard(),
                      title: 'Copy to clipboard'
                    }, [
                      m('svg[width=16][height=16][viewBox=0 0 24 24][fill=none][stroke=currentColor][stroke-width=2][stroke-linecap=round][stroke-linejoin=round]', [
                        m('path[stroke-linecap=round][stroke-linejoin=round][d=M8 16H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v2m-6 12h8a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-8a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2z"]'),
                        m('path[stroke-linecap=round][stroke-linejoin=round][d=M16 8v8m-4-5v5m-4-2v2"]')
                      ]),
                      m('span', 'Copy')
                    ])
                  ])
                ]),
                m('.editor-container', [
                  m('div#editor', {
                    style: `height: 100%; ${!optimizer.editorReady || optimizer.options.viewMode !== 'code' ? 'display: none;' : ''}`
                  }),
                  !optimizer.editorReady ? m('div', { style: 'display: flex; align-items: center; justify-content: center; height: 100%; color: #888;' }, 'Initializing editor...') : null,
                  optimizer.options.viewMode === 'tree' ? m(TreeView) : null
                ])
              ]),


            ]),
            m('div#dragbar', { style: 'width: 6px; cursor: col-resize; background: #666;' }),
            m('.preview-panel#right-panel', [

              m(".panel-header", [
                m("span", "Optimized SVG"),
                optimizer.optimizedSvg && m('div', { style: 'display:flex; gap:0.5rem; align-items:center;' }, [
                  m('button', { onclick: () => zoomSvg(1.2) }, '+'),
                  m('button', { onclick: () => zoomSvg(0.8) }, '-'),
                  m('button', { onclick: () => resetZoom() }, 'Reset'),
                ]),

                optimizer.optimizedSvg && m('button.download-btn', {
                  onclick: () => optimizer.downloadSvg()
                }, 'Download')
              ]),
              m('.preview-container', [
                optimizer.optimizedSvg ?
                  m.trust(optimizer.optimizedSvg) :
                  m('div', { style: 'color: #888; text-align: center' }, 'Preview will appear here')
              ])
            ])
          ])
        ]);
      }
    };


    let svgScale = 1;
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let startX = 0;
    let startY = 0;

    function applyTransform() {
      const svg = document.querySelector(".preview-container svg");
      if (svg) {
        svg.style.transform = `translate(${panX}px, ${panY}px) scale(${svgScale})`;
        svg.style.transformOrigin = "0 0";
      }
    }

    function zoomSvg(factor) {
      svgScale *= factor;
      applyTransform();
    }

    function resetZoom() {
      svgScale = 1;
      panX = 0;
      panY = 0;
      applyTransform();
    }

    function setupPanEvents() {
      const container = document.querySelector('.preview-container');
      if (!container) return;

      container.addEventListener('mousedown', (e) => {
        isPanning = true;
        startX = e.clientX - panX;
        startY = e.clientY - panY;
        container.style.cursor = 'grabbing';
      });

      container.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        panX = e.clientX - startX;
        panY = e.clientY - startY;
        applyTransform();
      });

      container.addEventListener('mouseup', () => {
        isPanning = false;
        container.style.cursor = 'default';
      });

      container.addEventListener('mouseleave', () => {
        isPanning = false;
        container.style.cursor = 'default';
      });

      container.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        svgScale *= delta;
        applyTransform();
      }, { passive: false });
    }


    m.mount(document.getElementById('app'), App);
    setupPanEvents();

    function copyToClipboard() {
      if (!optimizer.originalSvg) {
        alert('No SVG content to copy');
        return;
      }

      navigator.clipboard.writeText(optimizer.originalSvg).then(() => {
        // Show a temporary success message
        const copyBtn = document.querySelector('button[title="Copy to clipboard"]');
        if (copyBtn) {
          const originalText = copyBtn.innerHTML;
          copyBtn.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path stroke-linecap="round" stroke-linejoin="round" d="M20 6L9 17l-5-5"/>
            </svg>
            <span>Copied!</span>
          `;
          setTimeout(() => {
            copyBtn.innerHTML = originalText;
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard');
      });
    }

    document.addEventListener('keydown', (e) => {
      // Don't pan if typing in an input or textarea
      if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;

      const step = 20;
      const zoomStep = 1.1;
      switch (e.key) {
        case 'ArrowUp':
          panY -= step;
          break;
        case 'ArrowDown':
          panY += step;
          break;
        case 'ArrowLeft':
          panX -= step;
          break;
        case 'ArrowRight':
          panX += step;
          break;
        case '+':
        case '=':
          svgScale *= zoomStep;
          break;
        case '-':
        case '_':
          svgScale /= zoomStep;
          break;
        case '0':
          svgScale = 1;
          panX = 0;
          panY = 0;
          break;
        default:
          return;
      }
      applyTransform();
    });

  </script>
</body>

</html>